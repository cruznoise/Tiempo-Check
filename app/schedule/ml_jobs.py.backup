import subprocess
from datetime import date, timedelta, datetime
import os
from app.mysql_conn import get_mysql


def job_ml_train(app, usuario_id: int):
    print(f"[SCHED][ML] Entrenando modelo para user={usuario_id}")
    cmd = [
        "python3", "-m", "ml.pipeline", "train",
        "--usuario", str(usuario_id),
        "--hist", "90", "--holdout", "7"
    ]
    subprocess.run(cmd, check=True)

def job_ml_train_daily(app, usuario_id: int):
    """
    Wrapper explícito para entrenamiento periódico.
    Mantiene la importación usada por scheduler.py.
    """
    print(f"[SCHED][ML] Entrenamiento programado (weekly) user={usuario_id}")
    cmd = [
        "python3", "-m", "ml.pipeline", "train",
        "--usuario", str(usuario_id),
        "--hist", "180", "--holdout", "7"
    ]
    subprocess.run(cmd, check=True)

def job_ml_predict(app, usuario_id: int = None):
    """Genera predicciones para usuario(s)"""
    # Si no se especifica usuario, usar todos los activos
    if usuario_id is None:
        with app.app_context():
            from app.models.models import Usuario
            usuarios = Usuario.query.all()
            usuario_ids = [u.id for u in usuarios]
    else:
        usuario_ids = [usuario_id]
    
    tomorrow = (date.today() + timedelta(days=1)).isoformat()
    
    for uid in usuario_ids:
        print(f"[SCHED][ML] Predicción {tomorrow} user={uid}")
        cmd = [
            "python3", "-m", "ml.pipeline", "predict",
            "--usuario", str(uid),
            "--fecha", tomorrow,
            "--save-csv"
        ]
        try:
            subprocess.run(cmd, check=True)
        except subprocess.CalledProcessError as e:
            print(f"[SCHED][ERR][PREDICT] user={uid} → {e}")

def job_ml_catchup(app, usuario_id: int, dias: int = 3):
    """
    Verifica si existen predicciones faltantes en los últimos N días
    y las genera usando ml.pipeline.predict si es necesario.
    Compatible con v3.2 (usa ml_predicciones_future en lugar de ml_preds_diarias).
    """
    print(f"[SCHED][ML] Catch-up últimos {dias} días user={usuario_id}")

    with app.app_context():
        conexion = get_mysql()
        try:
            with conexion.cursor() as cursor:
                for i in range(dias, 0, -1):
                    d = (date.today() - timedelta(days=i)).isoformat()

                    cursor.execute("""
                        SELECT COUNT(*) 
                        FROM ml_predicciones_future 
                        WHERE usuario_id = %s AND fecha_pred = %s
                    """, (usuario_id, d))
                    existe = cursor.fetchone()[0]

                    if existe == 0:
                        cmd = [
                            "python3", "-m", "ml.pipeline", "predict",
                            "--usuario", str(usuario_id),
                            "--fecha", d,
                            "--save-csv"
                        ]
                        try:
                            subprocess.run(cmd, check=True)
                            print(f"[CATCHUP]  Generada predicción {d} para u{usuario_id}")
                        except subprocess.CalledProcessError as e:
                            print(f"[CATCHUP][ERROR]  u{usuario_id} fecha={d} -> {e}")
                    else:
                        print(f"[CATCHUP]  Ya existe predicción {d} user={usuario_id}, skip")

        except Exception as e:
            print(f"[CATCHUP][FATAL] {e}")
        finally:
            conexion.close()


def job_ml_train_cat(app, usuario_id: int):
    with app.app_context():
        from ml.pipeline import train_por_categoria
        print(f"[JOB][ML] Entrenamiento por categoría iniciado → usuario {usuario_id}")
        train_por_categoria(usuario_id)
        print(f"[JOB][ML] Entrenamiento por categoría finalizado → usuario {usuario_id}")

def job_ml_predict_multi(app, usuario_id: int = None, fecha_base=None):
    """Genera predicciones multi-horizonte para usuario(s)"""
    # Si no se especifica usuario, usar todos los activos
    if usuario_id is None:
        with app.app_context():
            from app.models.models import Usuario
            usuarios = Usuario.query.all()
            usuario_ids = [u.id for u in usuarios]
    else:
        usuario_ids = [usuario_id]
    
    if isinstance(fecha_base, str):
        target = fecha_base
    elif fecha_base is None:
        target = date.today().isoformat()
    else:
        target = fecha_base.isoformat()

    env = os.environ.copy()
    env["TIEMPOCHECK_ML_MODE"] = "1"
    
    for uid in usuario_ids:
        print(f"[SCHED][ML][MULTI] Predicciones extendidas user={uid}")
        cmd = [
            "python3", "-m", "ml.pipeline", "multi",
            "--usuario", str(uid),
            "--fecha", target,
            "--save-csv"
        ]
        
        try:
            subprocess.run(cmd, check=True, env=env)
            print(f"[SCHED][OK][MULTI] user={uid}")
        except subprocess.CalledProcessError as e:
            print(f"[SCHED][ERR][MULTI] user={uid} → {e}")

def job_ml_eval_daily(app=None, usuario_id=None):
    """Ejecuta evaluación diaria de desempeño multihorizonte"""
    print(f"[JOB][ML_EVAL] Iniciando evaluación diaria ({datetime.now().isoformat()})")
    try:
        subprocess.run(["python3", "-m", "ml.pipeline_eval"], check=True)
        print("[JOB][ML_EVAL] Evaluación completada con éxito.")
    except Exception as e:
        print(f"[JOB][ML_EVAL][ERROR] {e}")

def job_ml_eval_weekly(app=None):
    from ml.pipeline_eval_weekly import generar_resumen_semanal
    with app.app_context():
        print("[JOB][EVAL] Generando resumen semanal de precisión...")
        generar_resumen_semanal()
